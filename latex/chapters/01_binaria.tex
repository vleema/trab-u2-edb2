\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}

\usepackage{geometry}
\usepackage{tikz}
\geometry{a4paper, margin=1in}

\begin{document}

\section*{Árvore Binária}

Para criar uma árvore binária pouco desequilibrada a partir de uma lista de dados de entrada, podemos usar a estratégia de \textbf{divisão e conquista}. A ideia é organizar os dados de entrada, selecionar o elemento do meio como raiz e repetir esse processo para as sub-árvores da esqueda e direita.

\subsection*{Estratégia: Construção Balanceada com Lista Ordenada}

\begin{enumerate}
    \item \textbf{Ordenar os dados de entrada:}
    \begin{itemize}
        \item Se os dados não estiverem ordenados, ordene-os. Isso garante que a árvore seja uma \textit{árvore binária de busca}.
    \end{itemize}

    \item \textbf{Escolher o elemento do meio como raiz:}
    \begin{itemize}
        \item Divida a lista ao meio. O elemento central vai ser a raiz da árvore ou subárvore.
    \end{itemize}

    \item \textbf{Repetir de forma recursiva:}
    \begin{itemize}
        \item Para os elementos à esquerda do meio, crie a subárvore esquerda.
        \item Para os elementos à direita do meio, crie a subárvore direita.
    \end{itemize}

    \item \textbf{Continuar até que a lista esteja vazia:}
    \begin{itemize}
        \item A recursão terminará quando não houverem mais elementos na lista.
    \end{itemize}
\end{enumerate}

\subsection*{Exemplo: Construção da Árvore}

Considere os seguintes dados iniciais:

\[
80, \; 20, \; 50, \; 30, \; 90, \; 70, \; 10, \; 40, \; 60
\]

\noindent
Após ordenar, temos:

\[
10, \; 20, \; 30, \; 40, \; 50, \; 60, \; 70, \; 80, \; 90
\]

O elemento central (\textbf{50}) será a raiz.  
Agora, dividiremos a lista em duas partes:
\begin{itemize}
    \item Subárvore esquerda: \(10, 20, 30, 40\)
    \item Subárvore direita: \(60, 70, 80, 90\)
\end{itemize}

Construindo visualmente:

\begin{center}
\begin{tikzpicture}[
  level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  edge from parent/.style={draw, -latex},
  every node/.style={circle, draw, minimum size=8mm, font=\footnotesize}
]

% Raiz
\node {50}
  child {node {30}
    child {node {20}
      child {node {10}}
      child[missing]
    }
    child {node {40}}
  }
  child {node {70}
    child {node {60}}
    child {node {80}
        child[missing]
        child {node {90}}
    }
  };

\end{tikzpicture}
\end{center}

\subsection*{Explicação do Diagrama}
\begin{enumerate}
    \item O nó \textbf{50} é escolhido como raiz da árvore, pois é o elemento central da lista.
    \item A subárvore esquerda contém os números menores que 50 (\textbf{10, 20, 30, 40}):
    \begin{itemize}
        \item O elemento central (\textbf{30}) é escolhido como a raiz da subárvore esquerda.
        \item Os elementos menores que 30 (\textbf{10, 20}) formam sua subárvore esquerda.
        \item O elemento \textbf{40} forma a subárvore direita de 30.
    \end{itemize}
    \item A subárvore direita contém os números maiores que 50 (\textbf{60, 70, 80, 90}):
    \begin{itemize}
        \item O elemento central (\textbf{70}) é escolhido como a raiz da subárvore direita.
        \item O número \textbf{60} forma sua subárvore à esquerda.
        \item Os números \textbf{80} e \textbf{90} formam a subárvore à direita.
    \end{itemize}
\end{enumerate}

\section*{Implementação em C++}

\subsection*{1. Estrutura do Nó}
\begin{verbatim}
typedef struct nodo {
    int chave;
    struct nodo* esq;
    struct nodo* dir;

    // Construtor
    nodo(int chaveNovoNo) : chave(chaveNovoNo), esq(nullptr), dir(nullptr) {}

} no;
\end{verbatim}

\subsection*{2. Inserir}
\begin{verbatim}
no* inserir(no* origem, int chaveNovoNo) {
    if (origem == nullptr) {
        return new no(chaveNovoNo);
    }

    if (chaveNovoNo == origem->chave) {
        return origem;
    }

    if (chaveNovoNo < origem->chave) {
        origem->esq = inserir(origem->esq, chaveNovoNo);
    } else {
        origem->dir = inserir(origem->dir, chaveNovoNo);
    }

    return origem;
}
\end{verbatim}

\subsection*{3. Percurso Pré-Ordem}
\begin{verbatim}
void pre_ordem(no* pt) {
    std::cout << pt->chave << std::endl;
    if (pt->esq != NULL) {
        pre_ordem(pt->esq);
    }
    if (pt->dir != NULL) {
        pre_ordem(pt->dir);
    }
}
\end{verbatim}

\subsection*{4. Percurso Ordem Simétrica}
\begin{verbatim}
void ordem_simetrica(no* pt) {
    if (pt->esq != NULL) {
        ordem_simetrica(pt->esq);
    }
    std::cout << pt->chave << std::endl;
    if (pt->dir != NULL) {
        ordem_simetrica(pt->dir);
    }
}
\end{verbatim}

\subsection*{5. Percurso Pós-Ordem}
\begin{verbatim}
void pos_ordem(no* pt) {
    if (pt->esq != NULL) {
        pos_ordem(pt->esq);
    }
    if (pt->dir != NULL) {
        pos_ordem(pt->dir);
    }
    std::cout << pt->chave << std::endl;
}
\end{verbatim}

\subsection*{6. Auxiliar em Nível}
\begin{verbatim}
void auxiliar_em_nivel(no* no, int nivel, std::vector<std::vector<int>>& resultados) {
    if (!no) {
        return;
    }

    if (static_cast<int>(resultados.size()) == nivel) {
        resultados.push_back(std::vector<int>());
    }

    resultados[nivel].push_back(no->chave);

    auxiliar_em_nivel(no->esq, nivel + 1, resultados);
    auxiliar_em_nivel(no->dir, nivel + 1, resultados);
}
\end{verbatim}

\subsection*{7. Percurso por Nível}
\begin{verbatim}
void em_nivel(no* no) {
    std::vector<std::vector<int>> resultados;

    auxiliar_em_nivel(no, 0, resultados);

    for (const auto& nivel : resultados) {
        for (int chave : nivel) {
            std::cout << chave << " ";
        }
        std::cout << "| ";
    }
    std::cout << std::endl;
}
\end{verbatim}

\subsection*{8. Busca}
\begin{verbatim}
no* busca(no* raiz, int chave) {
    if (raiz == NULL || raiz->chave == chave) {
        return raiz;
    }
    if (chave < raiz->chave) {
        return busca(raiz->esq, chave);
    }
    if (chave > raiz->chave) {
        return busca(raiz->dir, chave);
    }
    return NULL;
}
\end{verbatim}

\subsection*{9. Busca Iterativa}
\begin{verbatim}
no* busca_iterativa(no* raiz, int chave) {
    while (raiz != NULL && raiz->chave != chave) {
        if (chave < raiz->chave) {
            raiz = raiz->esq;
        } else {
            raiz = raiz->dir;
        }
    }
    return raiz;
}
\end{verbatim}

\subsection*{10. Encontra Mínimo}
\begin{verbatim}
no* encontra_minimo(no* raiz) {
    while (raiz && raiz->esq) {
        raiz = raiz->esq;
    }
    return raiz;
}
\end{verbatim}

\subsection*{11. Remover}
\begin{verbatim}
no* remover(no* root, int chave) {
    if (!root)
        return nullptr;

    if (chave < root->chave) {
        root->esq = remover(root->esq, chave);
    } else if (chave > root->chave) {
        root->dir = remover(root->dir, chave);
    } else {
        // Caso 1: Nó é uma folha
        if (!root->esq && !root->dir) {
            delete root;
            return nullptr;
        }
        // Caso 2: Nó tem um único filho
        else if (!root->esq) {
            no* temp = root->dir;
            delete root;
            return temp;
        } else if (!root->dir) {
            no* temp = root->esq;
            delete root;
            return temp;
        }
        // Caso 3: Nó tem dois filhos
        else {
            no* temp = encontra_minimo(root->dir);
            root->chave = temp->chave;
            root->dir = remover(root->dir, temp->chave);
        }
    }
    return root;
}
\end{verbatim}


\end{document}
